#!/usr/bin/env perl

use warnings;
use strict;
use English qw(-no_match_vars);
use IO::File;
use List::Util qw(sum0);

our $VERSION = 0.2;

unless (@ARGV) {
	print <<DOC;

  A script to summarize the one or more lists generated by the app
  manage_repository.pl.
  
  It will count the number of lines and add up the size column, then
  print out the number of projects and the total size to STDOUT.
  Importantly, it will only keep and count the largest project size
  for duplicate project IDs.
  
  The size is printed as both comma-delimited bytes and formatted suffix.
  
  USAGE:
    summarize_lists.pl request.2024????.upload.txt 

DOC
	exit 0;
}

my %id2size;

foreach my $file (@ARGV) {
	my $fh = IO::File->new($file) or 
		die "Cannot open import file '$file'! $OS_ERROR\n";
	
	# check header
	my $header = $fh->getline;
	unless ($header =~ m/^ ID \ {4} \t Size/x) {
		# doesn't look like a list file
		print STDERR " > File '$file' does not look like a list file!\n";
		$fh->close;
		next;
	}
	
	# load remaining file
	while (my $l = $fh->getline) {
		chomp $l;
		my @bits = split /\t/, $l;
		
		# check ID
		my $id;
		if ( $bits[0] =~ /(?: \d+R | A\d+ )/x ) {
			$id = $bits[0];
		}
		else {
			next;
		}
		
		# add size
		my $size = 0;
		if ( $bits[1] =~ /^ (\d+ \. \d) G \s*$/x ) {
			$size += $1 * 1073741824;
		}
		elsif ( $bits[1] =~ /^ (\d+ \. \d) M \s* $/x ) {
			$size += $1 * 1048576;
		}
		elsif ( $bits[1] =~ /^ (\d+ \. \d) T \s* $/x ) {
			$size += $1 * 1099511627776;
		}
		elsif ( $bits[1] =~ /^ (\d+ \. \d) K \s* $/x ) {
			$size += $1 * 1024;
		}
		elsif ( $bits[1] =~ /^ (\d+) \s* $/x ) {
			$size += $1;
		}
		
		# store the largest size observed
		if ( exists $id2size{$id} ) {
			if ( $id2size{$id} < $size ) {
				$id2size{$id} = $size;
			}
		}
		else {
			$id2size{$id} = $size;
		}
	}
	
	$fh->close;
}

my $total = sprintf "%.0f", sum0( values %id2size ); # remove stray decimals!!??
my $count = scalar keys %id2size;
printf "\n %s (%s) for %d projects\n", format_with_commas($total), format_size($total),
	$count;


### Copied from Bio::ToolBox::utility
sub format_with_commas {

	# for formatting a number with commas
	my $number = shift;

	# check number
	my ( $integers, $decimals, $sign );
	if ( $number =~ m/^ (\-)? (\d+) \. (\d+) $/x ) {
		$sign     = $1;
		$integers = $2;
		$decimals = $3;
	}
	elsif ( $number =~ m/^ (\-)? (\d+) $/x ) {
		$sign     = $1;
		$integers = $2;
	}
	else {
		return $number;
	}

	# format
	my @digits = split //, $integers;
	my @formatted;
	while (@digits) {
		if ( @digits > 3 ) {
			unshift @formatted, pop @digits;
			unshift @formatted, pop @digits;
			unshift @formatted, pop @digits;
			unshift @formatted, ',';
		}
		else {
			while (@digits) {
				unshift @formatted, pop @digits;
			}
		}
	}

	# finished
	my $final = $sign ? $sign : q();
	$final .= join( q(), @formatted );
	$final .= '.' . $decimals if defined $decimals;
	return $final;
}


### Copied from manage_repository.pl
sub format_size {
	my $number = shift;
	# using binary sizes here
	if ($number > 1099511627776) {
		return sprintf("%.1fT", $number / 1099511627776);
	}
	elsif ($number > 1073741824) {
		return sprintf("%.1fG", $number / 1073741824);
	}
	elsif ($number > 1048576) {
		return sprintf("%.1fM", $number / 1048576);
	}
	elsif ($number > 1000) {
		# avoid weird formatting situations of >1000 and < 1024 bytes
		return sprintf("%.1fK", $number / 1024);
	}
	else {
		return sprintf("%dB", $number);
	}
}





